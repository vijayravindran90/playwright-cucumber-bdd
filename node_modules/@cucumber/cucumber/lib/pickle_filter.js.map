{"version":3,"file":"pickle_filter.js","sourceRoot":"","sources":["../src/pickle_filter.ts"],"names":[],"mappings":"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","sourcesContent":["import path from 'path'\nimport parse from '@cucumber/tag-expressions'\nimport { getGherkinScenarioLocationMap } from './formatter/helpers/gherkin_document_parser'\nimport { doesHaveValue, doesNotHaveValue } from './value_checker'\nimport * as messages from '@cucumber/messages'\nimport IGherkinDocument = messages.GherkinDocument\nimport IPickle = messages.Pickle\n\nconst FEATURE_LINENUM_REGEXP = /^(.*?)((?::[\\d]+)+)?$/\n\nexport interface IPickleFilterOptions {\n  cwd: string\n  featurePaths?: string[]\n  names?: string[]\n  tagExpression?: string\n}\n\nexport interface IMatchesAnyLineRequest {\n  gherkinDocument: messages.GherkinDocument\n  pickle: messages.Pickle\n}\n\nexport default class PickleFilter {\n  private readonly lineFilter: PickleLineFilter\n  private readonly nameFilter: PickleNameFilter\n  private readonly tagFilter: PickleTagFilter\n\n  constructor({\n    cwd,\n    featurePaths,\n    names,\n    tagExpression,\n  }: IPickleFilterOptions) {\n    this.lineFilter = new PickleLineFilter(cwd, featurePaths)\n    this.nameFilter = new PickleNameFilter(names)\n    this.tagFilter = new PickleTagFilter(tagExpression)\n  }\n\n  matches({\n    gherkinDocument,\n    pickle,\n  }: {\n    gherkinDocument: IGherkinDocument\n    pickle: IPickle\n  }): boolean {\n    return (\n      this.lineFilter.matchesAnyLine({ gherkinDocument, pickle }) &&\n      this.nameFilter.matchesAnyName(pickle) &&\n      this.tagFilter.matchesAllTagExpressions(pickle)\n    )\n  }\n}\n\nexport class PickleLineFilter {\n  private readonly featureUriToLinesMapping: Record<string, number[]>\n\n  constructor(cwd: string, featurePaths: string[] = []) {\n    this.featureUriToLinesMapping = this.getFeatureUriToLinesMapping({\n      cwd,\n      featurePaths,\n    })\n  }\n\n  getFeatureUriToLinesMapping({\n    cwd,\n    featurePaths,\n  }: {\n    cwd: string\n    featurePaths: string[]\n  }): Record<string, number[]> {\n    const mapping: Record<string, number[]> = {}\n    featurePaths.forEach((featurePath) => {\n      const match = FEATURE_LINENUM_REGEXP.exec(featurePath)\n      if (doesHaveValue(match)) {\n        let uri = match[1]\n        if (path.isAbsolute(uri)) {\n          uri = path.relative(cwd, uri)\n        } else {\n          uri = path.normalize(uri)\n        }\n        const linesExpression = match[2]\n        if (doesHaveValue(linesExpression)) {\n          if (doesNotHaveValue(mapping[uri])) {\n            mapping[uri] = []\n          }\n          linesExpression\n            .slice(1)\n            .split(':')\n            .forEach((line) => {\n              mapping[uri].push(parseInt(line))\n            })\n        }\n      }\n    })\n    return mapping\n  }\n\n  matchesAnyLine({ gherkinDocument, pickle }: IMatchesAnyLineRequest): boolean {\n    const uri = path.normalize(pickle.uri)\n    const linesToMatch = this.featureUriToLinesMapping[uri]\n    if (doesHaveValue(linesToMatch)) {\n      const gherkinScenarioLocationMap =\n        getGherkinScenarioLocationMap(gherkinDocument)\n      const pickleLines = new Set(\n        pickle.astNodeIds.map(\n          (sourceId) => gherkinScenarioLocationMap[sourceId].line\n        )\n      )\n      const linesIntersection = linesToMatch.filter((x) => pickleLines.has(x))\n      return linesIntersection.length > 0\n    }\n    return true\n  }\n}\n\nexport class PickleNameFilter {\n  private readonly names: string[]\n\n  constructor(names: string[] = []) {\n    this.names = names\n  }\n\n  matchesAnyName(pickle: messages.Pickle): boolean {\n    if (this.names.length === 0) {\n      return true\n    }\n    return this.names.some((name) => pickle.name.match(name))\n  }\n}\n\nexport class PickleTagFilter {\n  private readonly tagExpressionNode: any // cucumber-tag-expressions does not export interface\n\n  constructor(tagExpression: string) {\n    if (doesHaveValue(tagExpression) && tagExpression !== '') {\n      this.tagExpressionNode = parse(tagExpression)\n    }\n  }\n\n  matchesAllTagExpressions(pickle: messages.Pickle): boolean {\n    if (doesNotHaveValue(this.tagExpressionNode)) {\n      return true\n    }\n    return this.tagExpressionNode.evaluate(pickle.tags.map((x) => x.name))\n  }\n}\n"]}