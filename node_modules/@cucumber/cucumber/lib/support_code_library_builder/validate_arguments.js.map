{"version":3,"file":"validate_arguments.js","sourceRoot":"","sources":["../../src/support_code_library_builder/validate_arguments.ts"],"names":[],"mappings":";;AAcA,MAAM,iBAAiB,GAAG;IACxB,YAAY,EAAE,oBAAoB;IAClC,SAAS,CAAC,EAAE,OAAO,EAAwB;QACzC,OAAO,OAAO,OAAO,KAAK,QAAQ,CAAA;IACpC,CAAC;CACF,CAAA;AAED,MAAM,wBAAwB,GAAG;IAC/B,UAAU,EAAE,mBAAmB;IAC/B,YAAY,EAAE,SAAS;IACvB,SAAS,CAAC,EAAE,OAAO,EAAwB;QACzC,OAAO,OAAO,CAAC,OAAO,IAAI,IAAI,IAAI,OAAO,OAAO,CAAC,OAAO,KAAK,QAAQ,CAAA;IACvE,CAAC;CACF,CAAA;AAED,MAAM,YAAY,GAAG;IACnB,YAAY,EAAE,UAAU;IACxB,SAAS,CAAC,EAAE,IAAI,EAAwB;QACtC,OAAO,OAAO,IAAI,KAAK,UAAU,CAAA;IACnC,CAAC;CACF,CAAA;AAED,MAAM,WAAW,GAAkC;IACjD,iBAAiB,EAAE;QACjB,EAAE,UAAU,EAAE,gBAAgB,EAAE,GAAG,iBAAiB,EAAE;QACtD,wBAAwB;QACxB,EAAE,UAAU,EAAE,iBAAiB,EAAE,GAAG,YAAY,EAAE;KACnD;IACD,kBAAkB,EAAE;QAClB,EAAE,UAAU,EAAE,gBAAgB,EAAE,GAAG,iBAAiB,EAAE;QACtD;YACE,UAAU,EAAE,gBAAgB;YAC5B,YAAY,EAAE,QAAQ;YACtB,SAAS,CAAC,EAAE,OAAO,EAAE;gBACnB,OAAO,OAAO,CAAC,IAAI,IAAI,IAAI,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,CAAA;YACjE,CAAC;SACF;QACD,wBAAwB;QACxB,EAAE,UAAU,EAAE,iBAAiB,EAAE,GAAG,YAAY,EAAE;KACnD;IACD,kBAAkB,EAAE;QAClB,EAAE,UAAU,EAAE,gBAAgB,EAAE,GAAG,iBAAiB,EAAE;QACtD;YACE,UAAU,EAAE,gBAAgB;YAC5B,YAAY,EAAE,QAAQ;YACtB,SAAS,CAAC,EAAE,OAAO,EAAE;gBACnB,OAAO,OAAO,CAAC,IAAI,IAAI,IAAI,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,CAAA;YACjE,CAAC;SACF;QACD,wBAAwB;QACxB,EAAE,UAAU,EAAE,iBAAiB,EAAE,GAAG,YAAY,EAAE;KACnD;IACD,UAAU,EAAE;QACV;YACE,UAAU,EAAE,gBAAgB;YAC5B,YAAY,EAAE,8BAA8B;YAC5C,SAAS,CAAC,EAAE,OAAO,EAAE;gBACnB,OAAO,OAAO,YAAY,MAAM,IAAI,OAAO,OAAO,KAAK,QAAQ,CAAA;YACjE,CAAC;SACF;QACD,EAAE,UAAU,EAAE,iBAAiB,EAAE,GAAG,iBAAiB,EAAE;QACvD,wBAAwB;QACxB,EAAE,UAAU,EAAE,gBAAgB,EAAE,GAAG,YAAY,EAAE;KAClD;CACF,CAAA;AAED,SAAwB,iBAAiB,CAAC,EACxC,IAAI,EACJ,MAAM,EACN,QAAQ,GAKT;IACC,WAAW,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,EAAE,UAAU,EAAE,YAAY,EAAE,SAAS,EAAE,EAAE,EAAE;QACtE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;YACpB,MAAM,IAAI,KAAK,CACb,GAAG,QAAQ,aAAa,UAAU,iBAAiB,YAAY,EAAE,CAClE,CAAA;SACF;IACH,CAAC,CAAC,CAAA;AACJ,CAAC;AAhBD,oCAgBC","sourcesContent":["import { DefineStepPattern, IDefineStepOptions } from './types'\n\ninterface IValidation {\n  identifier: string\n  expectedType: string\n  predicate: (args: any) => boolean\n}\n\ninterface IDefineStepArguments {\n  pattern?: DefineStepPattern\n  options?: IDefineStepOptions\n  code?: Function\n}\n\nconst optionsValidation = {\n  expectedType: 'object or function',\n  predicate({ options }: IDefineStepArguments) {\n    return typeof options === 'object'\n  },\n}\n\nconst optionsTimeoutValidation = {\n  identifier: '\"options.timeout\"',\n  expectedType: 'integer',\n  predicate({ options }: IDefineStepArguments) {\n    return options.timeout == null || typeof options.timeout === 'number'\n  },\n}\n\nconst fnValidation = {\n  expectedType: 'function',\n  predicate({ code }: IDefineStepArguments) {\n    return typeof code === 'function'\n  },\n}\n\nconst validations: Record<string, IValidation[]> = {\n  defineTestRunHook: [\n    { identifier: 'first argument', ...optionsValidation },\n    optionsTimeoutValidation,\n    { identifier: 'second argument', ...fnValidation },\n  ],\n  defineTestCaseHook: [\n    { identifier: 'first argument', ...optionsValidation },\n    {\n      identifier: '\"options.tags\"',\n      expectedType: 'string',\n      predicate({ options }) {\n        return options.tags == null || typeof options.tags === 'string'\n      },\n    },\n    optionsTimeoutValidation,\n    { identifier: 'second argument', ...fnValidation },\n  ],\n  defineTestStepHook: [\n    { identifier: 'first argument', ...optionsValidation },\n    {\n      identifier: '\"options.tags\"',\n      expectedType: 'string',\n      predicate({ options }) {\n        return options.tags == null || typeof options.tags === 'string'\n      },\n    },\n    optionsTimeoutValidation,\n    { identifier: 'second argument', ...fnValidation },\n  ],\n  defineStep: [\n    {\n      identifier: 'first argument',\n      expectedType: 'string or regular expression',\n      predicate({ pattern }) {\n        return pattern instanceof RegExp || typeof pattern === 'string'\n      },\n    },\n    { identifier: 'second argument', ...optionsValidation },\n    optionsTimeoutValidation,\n    { identifier: 'third argument', ...fnValidation },\n  ],\n}\n\nexport default function validateArguments({\n  args,\n  fnName,\n  location,\n}: {\n  args?: IDefineStepArguments\n  fnName: string\n  location: string\n}): void {\n  validations[fnName].forEach(({ identifier, expectedType, predicate }) => {\n    if (!predicate(args)) {\n      throw new Error(\n        `${location}: Invalid ${identifier}: should be a ${expectedType}`\n      )\n    }\n  })\n}\n"]}