{"version":3,"file":"builder.js","sourceRoot":"","sources":["../../src/formatter/builder.ts"],"names":[],"mappings":"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","sourcesContent":["import getColorFns from './get_color_fns'\nimport JavascriptSnippetSyntax from './step_definition_snippet_builder/javascript_snippet_syntax'\nimport path from 'path'\nimport StepDefinitionSnippetBuilder from './step_definition_snippet_builder'\nimport { ISupportCodeLibrary } from '../support_code_library_builder/types'\nimport Formatter, {\n  FormatOptions,\n  IFormatterCleanupFn,\n  IFormatterLogFn,\n} from '.'\nimport { doesHaveValue, doesNotHaveValue } from '../value_checker'\nimport { EventEmitter } from 'events'\nimport EventDataCollector from './helpers/event_data_collector'\nimport { Writable as WritableStream } from 'stream'\nimport { SnippetInterface } from './step_definition_snippet_builder/snippet_syntax'\nimport { fileURLToPath, pathToFileURL } from 'url'\nimport Formatters from './helpers/formatters'\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst { importer } = require('../importer')\n\ninterface IGetStepDefinitionSnippetBuilderOptions {\n  cwd: string\n  snippetInterface?: SnippetInterface\n  snippetSyntax?: string\n  supportCodeLibrary: ISupportCodeLibrary\n}\n\nexport interface IBuildOptions {\n  env: NodeJS.ProcessEnv\n  cwd: string\n  eventBroadcaster: EventEmitter\n  eventDataCollector: EventDataCollector\n  log: IFormatterLogFn\n  parsedArgvOptions: FormatOptions\n  stream: WritableStream\n  cleanup: IFormatterCleanupFn\n  supportCodeLibrary: ISupportCodeLibrary\n}\n\nconst FormatterBuilder = {\n  async build(type: string, options: IBuildOptions): Promise<Formatter> {\n    const FormatterConstructor = await FormatterBuilder.getConstructorByType(\n      type,\n      options.cwd\n    )\n    const colorFns = getColorFns(\n      options.stream,\n      options.env,\n      options.parsedArgvOptions.colorsEnabled\n    )\n    const snippetBuilder =\n      await FormatterBuilder.getStepDefinitionSnippetBuilder({\n        cwd: options.cwd,\n        snippetInterface: options.parsedArgvOptions.snippetInterface,\n        snippetSyntax: options.parsedArgvOptions.snippetSyntax,\n        supportCodeLibrary: options.supportCodeLibrary,\n      })\n    return new FormatterConstructor({\n      colorFns,\n      snippetBuilder,\n      ...options,\n    })\n  },\n\n  async getConstructorByType(\n    type: string,\n    cwd: string\n  ): Promise<typeof Formatter> {\n    const formatters: Record<string, typeof Formatter> =\n      Formatters.getFormatters()\n\n    return formatters[type]\n      ? formatters[type]\n      : await FormatterBuilder.loadCustomClass('formatter', type, cwd)\n  },\n\n  async getStepDefinitionSnippetBuilder({\n    cwd,\n    snippetInterface,\n    snippetSyntax,\n    supportCodeLibrary,\n  }: IGetStepDefinitionSnippetBuilderOptions) {\n    if (doesNotHaveValue(snippetInterface)) {\n      snippetInterface = SnippetInterface.Synchronous\n    }\n    let Syntax = JavascriptSnippetSyntax\n    if (doesHaveValue(snippetSyntax)) {\n      Syntax = await FormatterBuilder.loadCustomClass(\n        'syntax',\n        snippetSyntax,\n        cwd\n      )\n    }\n    return new StepDefinitionSnippetBuilder({\n      snippetSyntax: new Syntax(snippetInterface),\n      parameterTypeRegistry: supportCodeLibrary.parameterTypeRegistry,\n    })\n  },\n\n  async loadCustomClass(\n    type: 'formatter' | 'syntax',\n    descriptor: string,\n    cwd: string\n  ) {\n    let normalised: URL | string = descriptor\n    if (descriptor.startsWith('.')) {\n      normalised = pathToFileURL(path.resolve(cwd, descriptor))\n    } else if (descriptor.startsWith('file://')) {\n      normalised = new URL(descriptor)\n    }\n    let CustomClass = await FormatterBuilder.loadFile(normalised)\n    CustomClass = FormatterBuilder.resolveConstructor(CustomClass)\n    if (doesHaveValue(CustomClass)) {\n      return CustomClass\n    } else {\n      throw new Error(\n        `Custom ${type} (${descriptor}) does not export a function/class`\n      )\n    }\n  },\n\n  async loadFile(urlOrName: URL | string) {\n    let result\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      result = require(typeof urlOrName === 'string'\n        ? urlOrName\n        : fileURLToPath(urlOrName))\n    } catch (error) {\n      if (error.code === 'ERR_REQUIRE_ESM') {\n        result = await importer(urlOrName)\n      } else {\n        throw error\n      }\n    }\n    return result\n  },\n\n  resolveConstructor(ImportedCode: any) {\n    if (doesNotHaveValue(ImportedCode)) {\n      return null\n    }\n    if (typeof ImportedCode === 'function') {\n      return ImportedCode\n    } else if (\n      typeof ImportedCode === 'object' &&\n      typeof ImportedCode.default === 'function'\n    ) {\n      return ImportedCode.default\n    }\n    return null\n  },\n}\n\nexport default FormatterBuilder\n"]}