{"version":3,"file":"javascript_snippet_syntax.js","sourceRoot":"","sources":["../../../src/formatter/step_definition_snippet_builder/javascript_snippet_syntax.ts"],"names":[],"mappings":";;AACA,qDAIyB;AAEzB,MAAM,aAAa,GAAG,UAAU,CAAA;AAEhC,MAAqB,uBAAuB;IAG1C,YAAY,gBAAkC;QAC5C,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAA;IAC1C,CAAC;IAED,KAAK,CAAC,EACJ,OAAO,EACP,oBAAoB,EACpB,YAAY,EACZ,kBAAkB,GACS;QAC3B,IAAI,eAAe,GAAG,WAAW,CAAA;QACjC,IAAI,IAAI,CAAC,gBAAgB,KAAK,iCAAgB,CAAC,UAAU,EAAE;YACzD,eAAe,GAAG,QAAQ,GAAG,eAAe,CAAA;SAC7C;aAAM,IAAI,IAAI,CAAC,gBAAgB,KAAK,iCAAgB,CAAC,SAAS,EAAE;YAC/D,eAAe,IAAI,GAAG,CAAA;SACvB;QAED,IAAI,cAAsB,CAAA;QAC1B,IAAI,IAAI,CAAC,gBAAgB,KAAK,iCAAgB,CAAC,QAAQ,EAAE;YACvD,cAAc,GAAG,GAAG,aAAa,oBAAoB,CAAA;SACtD;aAAM,IAAI,IAAI,CAAC,gBAAgB,KAAK,iCAAgB,CAAC,OAAO,EAAE;YAC7D,cAAc,GAAG,oCAAoC,CAAA;SACtD;aAAM;YACL,cAAc,GAAG,mBAAmB,CAAA;SACrC;QAED,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,GAAG,CAChD,CAAC,mBAAmB,EAAE,KAAK,EAAE,EAAE;YAC7B,MAAM,MAAM,GAAG,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAA;YACvC,MAAM,iBAAiB,GACrB,mBAAmB,CAAC,cAAc,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAA;YAC/D,IAAI,IAAI,CAAC,gBAAgB,KAAK,iCAAgB,CAAC,QAAQ,EAAE;gBACvD,iBAAiB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;aACtC;YACD,OAAO,GAAG,MAAM,GAAG,YAAY,KAAK,IAAI,CAAC,uBAAuB,CAC9D,mBAAmB,CACpB,MAAM,eAAe,IAAI,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAA;QAC/D,CAAC,CACF,CAAA;QAED,OAAO,CACL,GAAG,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,OAAO,IAAI;YAChD,KAAK,cAAc,IAAI;YACvB,KAAK,CACN,CAAA;IACH,CAAC;IAEO,uBAAuB,CAAC,mBAAwC;QACtE,IAAI,MAAM,GAAG,mBAAmB,CAAC,MAAM,CAAA;QACvC,iEAAiE;QACjE,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;QACtC,8DAA8D;QAC9D,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;QACpC,OAAO,MAAM,CAAA;IACf,CAAC;CACF;AA1DD,0CA0DC","sourcesContent":["import { GeneratedExpression } from '@cucumber/cucumber-expressions'\nimport {\n  ISnippetSnytax,\n  ISnippetSyntaxBuildOptions,\n  SnippetInterface,\n} from './snippet_syntax'\n\nconst CALLBACK_NAME = 'callback'\n\nexport default class JavaScriptSnippetSyntax implements ISnippetSnytax {\n  private readonly snippetInterface: SnippetInterface\n\n  constructor(snippetInterface: SnippetInterface) {\n    this.snippetInterface = snippetInterface\n  }\n\n  build({\n    comment,\n    generatedExpressions,\n    functionName,\n    stepParameterNames,\n  }: ISnippetSyntaxBuildOptions): string {\n    let functionKeyword = 'function '\n    if (this.snippetInterface === SnippetInterface.AsyncAwait) {\n      functionKeyword = 'async ' + functionKeyword\n    } else if (this.snippetInterface === SnippetInterface.Generator) {\n      functionKeyword += '*'\n    }\n\n    let implementation: string\n    if (this.snippetInterface === SnippetInterface.Callback) {\n      implementation = `${CALLBACK_NAME}(null, 'pending');`\n    } else if (this.snippetInterface === SnippetInterface.Promise) {\n      implementation = \"return Promise.resolve('pending');\"\n    } else {\n      implementation = \"return 'pending';\"\n    }\n\n    const definitionChoices = generatedExpressions.map(\n      (generatedExpression, index) => {\n        const prefix = index === 0 ? '' : '// '\n        const allParameterNames =\n          generatedExpression.parameterNames.concat(stepParameterNames)\n        if (this.snippetInterface === SnippetInterface.Callback) {\n          allParameterNames.push(CALLBACK_NAME)\n        }\n        return `${prefix + functionName}('${this.escapeSpecialCharacters(\n          generatedExpression\n        )}', ${functionKeyword}(${allParameterNames.join(', ')}) {\\n`\n      }\n    )\n\n    return (\n      `${definitionChoices.join('')}  // ${comment}\\n` +\n      `  ${implementation}\\n` +\n      '});'\n    )\n  }\n\n  private escapeSpecialCharacters(generatedExpression: GeneratedExpression) {\n    let source = generatedExpression.source\n    // double up any backslashes because we're in a javascript string\n    source = source.replace(/\\\\/g, '\\\\\\\\')\n    // escape any single quotes because that's our quote delimiter\n    source = source.replace(/'/g, \"\\\\'\")\n    return source\n  }\n}\n"]}