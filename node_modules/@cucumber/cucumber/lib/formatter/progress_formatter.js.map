{"version":3,"file":"progress_formatter.js","sourceRoot":"","sources":["../../src/formatter/progress_formatter.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,4EAAkD;AAClD,oDAAgD;AAEhD,6DAA8C;AAI9C,MAAM,wBAAwB,GAC5B,IAAI,GAAG,CAAC;IACN,CAAC,QAAQ,CAAC,oBAAoB,CAAC,SAAS,EAAE,GAAG,CAAC;IAC9C,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,EAAE,GAAG,CAAC;IAC3C,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,EAAE,GAAG,CAAC;IAC3C,CAAC,QAAQ,CAAC,oBAAoB,CAAC,OAAO,EAAE,GAAG,CAAC;IAC5C,CAAC,QAAQ,CAAC,oBAAoB,CAAC,OAAO,EAAE,GAAG,CAAC;IAC5C,CAAC,QAAQ,CAAC,oBAAoB,CAAC,SAAS,EAAE,GAAG,CAAC;CAC/C,CAAC,CAAA;AAEJ,MAAqB,iBAAkB,SAAQ,2BAAgB;IAI7D,YAAY,OAA0B;QACpC,OAAO,CAAC,gBAAgB,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,QAAmB,EAAE,EAAE;YAC9D,IAAI,IAAA,6BAAa,EAAC,QAAQ,CAAC,eAAe,CAAC,EAAE;gBAC3C,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;aACjB;iBAAM,IAAI,IAAA,6BAAa,EAAC,QAAQ,CAAC,gBAAgB,CAAC,EAAE;gBACnD,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAA;aAC5C;QACH,CAAC,CAAC,CAAA;QACF,KAAK,CAAC,OAAO,CAAC,CAAA;IAChB,CAAC;IAED,WAAW,CAAC,EAAE,cAAc,EAAE,EAAE,MAAM,EAAE,EAAqB;QAC3D,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,MAAM,CAAC,CAC/C,wBAAwB,CAAC,GAAG,CAAC,MAAM,CAAC,CACrC,CAAA;QACD,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;IACrB,CAAC;;AApBH,oCAqBC;AApBwB,+BAAa,GAClC,oCAAoC,CAAA","sourcesContent":["import SummaryFormatter from './summary_formatter'\nimport { doesHaveValue } from '../value_checker'\nimport { IFormatterOptions } from './index'\nimport * as messages from '@cucumber/messages'\nimport IEnvelope = messages.Envelope\nimport ITestStepFinished = messages.TestStepFinished\n\nconst STATUS_CHARACTER_MAPPING: Map<messages.TestStepResultStatus, string> =\n  new Map([\n    [messages.TestStepResultStatus.AMBIGUOUS, 'A'],\n    [messages.TestStepResultStatus.FAILED, 'F'],\n    [messages.TestStepResultStatus.PASSED, '.'],\n    [messages.TestStepResultStatus.PENDING, 'P'],\n    [messages.TestStepResultStatus.SKIPPED, '-'],\n    [messages.TestStepResultStatus.UNDEFINED, 'U'],\n  ])\n\nexport default class ProgressFormatter extends SummaryFormatter {\n  public static readonly documentation: string =\n    'Prints one character per scenario.'\n\n  constructor(options: IFormatterOptions) {\n    options.eventBroadcaster.on('envelope', (envelope: IEnvelope) => {\n      if (doesHaveValue(envelope.testRunFinished)) {\n        this.log('\\n\\n')\n      } else if (doesHaveValue(envelope.testStepFinished)) {\n        this.logProgress(envelope.testStepFinished)\n      }\n    })\n    super(options)\n  }\n\n  logProgress({ testStepResult: { status } }: ITestStepFinished): void {\n    const character = this.colorFns.forStatus(status)(\n      STATUS_CHARACTER_MAPPING.get(status)\n    )\n    this.log(character)\n  }\n}\n"]}