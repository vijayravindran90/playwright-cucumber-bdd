{"version":3,"file":"formatters.js","sourceRoot":"","sources":["../../src/api/formatters.ts"],"names":[],"mappings":";;;;;;AAIA,+BAAgC;AAEhC,mEAAmD;AACnD,+CAAsB;AACtB,gDAAuB;AAIhB,KAAK,UAAU,oBAAoB,CAAC,EACzC,GAAG,EACH,GAAG,EACH,MAAM,EACN,MAAM,EACN,aAAa,EACb,gBAAgB,EAChB,kBAAkB,EAClB,aAAa,EACb,kBAAkB,GAYnB;IACC,KAAK,UAAU,mBAAmB,CAChC,MAAwB,EACxB,MAAc,EACd,IAAY;QAEZ,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAY,EAAE,EAAE;YAClC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;YAC3B,aAAa,EAAE,CAAA;QACjB,CAAC,CAAC,CAAA;QACF,MAAM,WAAW,GAAG;YAClB,GAAG;YACH,GAAG;YACH,gBAAgB;YAChB,kBAAkB;YAClB,GAAG,EAAE,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;YAC9B,iBAAiB,EAAE,aAAa,CAAC,OAAO;YACxC,MAAM;YACN,OAAO,EACL,MAAM,KAAK,MAAM;gBACf,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC,MAAM,OAAO,CAAC,OAAO,EAAE;gBACrC,CAAC,CAAC,IAAA,gBAAS,EAAM,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC7C,kBAAkB;SACnB,CAAA;QACD,IAAI,IAAI,KAAK,cAAc,IAAI,CAAE,MAAyB,CAAC,KAAK,EAAE;YAChE,MAAM,CAAC,IAAI,CACT,sDAAsD,MAAM,oDAAoD,CACjH,CAAA;YACD,IAAI,GAAG,UAAU,CAAA;SAClB;QACD,OAAO,MAAM,iBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,WAAW,CAAC,CAAA;IACxD,CAAC;IAED,MAAM,UAAU,GAAgB,EAAE,CAAA;IAElC,UAAU,CAAC,IAAI,CACb,MAAM,mBAAmB,CAAC,MAAM,EAAE,QAAQ,EAAE,aAAa,CAAC,MAAM,CAAC,CAClE,CAAA;IAED,KAAK,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;QAChE,MAAM,MAAM,GAAqB,YAAE,CAAC,iBAAiB,CAAC,IAAI,EAAE;YAC1D,EAAE,EAAE,MAAM,YAAE,CAAC,IAAI,CAAC,cAAI,CAAC,OAAO,CAAC,GAAG,EAAE,MAAM,CAAC,EAAE,GAAG,CAAC;SAClD,CAAC,CAAA;QACF,UAAU,CAAC,IAAI,CAAC,MAAM,mBAAmB,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAA;KACjE;IAED,OAAO,KAAK;QACV,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAA;IACpE,CAAC,CAAA;AACH,CAAC;AAtED,oDAsEC","sourcesContent":["import Formatter, { IFormatterStream } from '../formatter'\nimport { EventEmitter } from 'events'\nimport { EventDataCollector } from '../formatter/helpers'\nimport { ISupportCodeLibrary } from '../support_code_library_builder/types'\nimport { promisify } from 'util'\nimport { WriteStream as TtyWriteStream } from 'tty'\nimport FormatterBuilder from '../formatter/builder'\nimport fs from 'mz/fs'\nimport path from 'path'\nimport { IRunOptionsFormats } from './types'\nimport { ILogger } from '../logger'\n\nexport async function initializeFormatters({\n  env,\n  cwd,\n  stdout,\n  logger,\n  onStreamError,\n  eventBroadcaster,\n  eventDataCollector,\n  configuration,\n  supportCodeLibrary,\n}: {\n  env: NodeJS.ProcessEnv\n  cwd: string\n  stdout: IFormatterStream\n  stderr: IFormatterStream\n  logger: ILogger\n  onStreamError: () => void\n  eventBroadcaster: EventEmitter\n  eventDataCollector: EventDataCollector\n  configuration: IRunOptionsFormats\n  supportCodeLibrary: ISupportCodeLibrary\n}): Promise<() => Promise<void>> {\n  async function initializeFormatter(\n    stream: IFormatterStream,\n    target: string,\n    type: string\n  ): Promise<Formatter> {\n    stream.on('error', (error: Error) => {\n      logger.error(error.message)\n      onStreamError()\n    })\n    const typeOptions = {\n      env,\n      cwd,\n      eventBroadcaster,\n      eventDataCollector,\n      log: stream.write.bind(stream),\n      parsedArgvOptions: configuration.options,\n      stream,\n      cleanup:\n        stream === stdout\n          ? async () => await Promise.resolve()\n          : promisify<any>(stream.end.bind(stream)),\n      supportCodeLibrary,\n    }\n    if (type === 'progress-bar' && !(stream as TtyWriteStream).isTTY) {\n      logger.warn(\n        `Cannot use 'progress-bar' formatter for output to '${target}' as not a TTY. Switching to 'progress' formatter.`\n      )\n      type = 'progress'\n    }\n    return await FormatterBuilder.build(type, typeOptions)\n  }\n\n  const formatters: Formatter[] = []\n\n  formatters.push(\n    await initializeFormatter(stdout, 'stdout', configuration.stdout)\n  )\n\n  for (const [target, type] of Object.entries(configuration.files)) {\n    const stream: IFormatterStream = fs.createWriteStream(null, {\n      fd: await fs.open(path.resolve(cwd, target), 'w'),\n    })\n    formatters.push(await initializeFormatter(stream, target, type))\n  }\n\n  return async function () {\n    await Promise.all(formatters.map(async (f) => await f.finished()))\n  }\n}\n"]}